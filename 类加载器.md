# 类加载器
- 在双亲委托机制中，各个加载器按照父子关系形成**树形结构**，除了根类加载器之外，其余的类加载器都**有且只有一个父类加载器**

## 获取ClassLoader 的方法

- 获取当前类的ClassLoader
    - `clazz.getClassLoader`
- 获取当前线程上下文的ClassLoader
    - `Thread.currentThread().getContextClassLoader()`
- 获取系统的ClassLoader
    - `ClassLoader.getSystemClassLoader()`
- 获得调用者的ClassLoader
    - `DriverManager.getCallerClassLoader()`
    
## 类加载器的JavaDoc分析
```text
类加载器是负责加载类的对象。

ClassLoader类是一个抽象类。

给定类的二进制名称，类加载器应尝试查找或生成构成该类定义的数据。

一种典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。

每个Class对象都包含对定义它的ClassLoader的引用。

数组类的类对象不是由类加载器创建的，而是根据Java运行时的要求自动创建的。由Class.getClassLoader（）返回的数组类的类加载器与其元素类型的类加载器相同。

如果元素类型是原始类型，则数组类没有类加载器。

应用程序实现ClassLoader的子类，以扩展Java虚拟机动态加载类的方式。

安全管理人员通常可以使用类加载器来指示安全域。 ClassLoader类使用委托模型搜索类和资源。

每个ClassLoader实例都有一个关联的父类加载器。
当请求查找类或资源时，ClassLoader实例会将对类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。

虚拟机的内置类加载器（称为“引导类加载器”）本身没有父级，但可以用作ClassLoader实例的父级。
支持并发加载类的类加载器称为具有并行功能的类加载器，并且要求它们通过调用ClassLoader.registerAsParallelCapable方法在其类初始化时进行自身注册。

请注意，默认情况下，ClassLoader类注册为具有并行功能。
但是，如果它们的子类具有并行功能，则仍然需要注册自己。

在委派模型不是严格分层的环境中，类加载器需要具有并行功能，否则类加载会导致死锁，因为在类加载过程中保持了加载器锁（请参见loadClass方法）。

通常，Java虚拟机以平台相关的方式从本地文件系统加载类。

例如，在UNIX系统上，虚拟机从CLASSPATH环境变量定义的目录中加载类。

但是，某些类可能不是源自文件的。它们可能源自其他来源，例如网络，也可能由应用程序构造。

方法defineClass将字节数组转换为Class类的实例。

可以使用Class.newInstance创建此新定义的类的实例。
由类加载器创建的对象的方法和构造函数可以引用其他类。
为了确定所引用的类，Java虚拟机将调用最初创建该类的类加载器的loadClass方法。

```

## 自定义类加载器
[MyTest16.java](jvm_lecture/src/main/java/com/winterfell/jvm/classloader/MyTest16.java)

**注意点**
- 把ide自动编译出来的class对象删除
    - 自定义类加载器在加载的时候会委托给父类加载器（系统类加载器）去加载
    - 系统类加载器会加载classpath下的东西,MyTest1.class会被加载，tmp目录里面的MyTest1.class不会被加载
    
**类加载器的命名空间**
- 每个类加载器都有自己的命名空间，**命名空间由该加载器及所有父加载器所加载的类组成**
- 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间，有可能会出现类的完整名字（包括类名和包名）相同的两个类

**不同类加载器命名空间的关系**
- 同一个命名空间的类是相互可见的
- 子加载器的命名空间包含所有父加载器的命名空间。
    - 因此由子加载器加载的类能看见父加载器加载的类
    - 例如系统类加载器加载的类能看见根类加载器加载的类
- 由父加载器加载的类不能看见子加载器加载的类
    - 如果两个加载器之间没有直接或者间接的父子关系，那么它们各自加载的类相互**不可见**

**类加载器的命名空间的重要说明**
- 子加载器加载的类可以访问父加载器加载的类
- 父加载器加载的类不能访问子加载器加载的类

## 类的卸载

- 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
- Java虚拟机自带的类加载器包括根类加载器、扩展类加载器、系统类加载器
- Java虚拟机本身会使用引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可以触及的

## 双亲委派机制
![类加载器双亲委派机制](img/类加载/类加载器双亲委派机制.jpg)