# JVM垃圾收集器

## CMS 垃圾收集器
> Concurrent Mark Sweep (并发标记清除)
### 枚举根节点
当执行系统停顿下来后，并不需要一个不漏检查所有执行上下文和全局的引用位置，虚拟机应当时有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为 `OopMap`的数据结构来达到这个目的

### 安全点
在 `OopMap` 的帮助下，HotSpot可以快速且准确地完成GCRoots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说`OopMap`内容变化的指令非常多，如果为每一条指令都生成对应的 `OopMap`，那将会需要大量的额外空间，这样GC的空间成本将会变得非常高

实际上，HotSpot并没有为每条指令都生成 `OopMap`，而只是在 “特定的位置” 记录了这些信息，这些位置称之为安全点（`SafePoint`），即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停

`SafePoint`的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载。所以，安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的--因为每条指令的执行时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间执行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生`SafePoint`

对于 `SafePoint`，另一个需要考虑的问题时如何在GC发生时让所有线程（这里不包括执行JNI调用的线程） 都“跑” 到最近的安全点上再停顿下来：抢占式中断（`Preemptive Suspension`）和主动式终端（`Voluntary Suspension`）
- 抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让“它”跑到安全点上
- 主动式终端：当GC需要中断线程的时候，不直接对线程操作，仅仅简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外在加上创建对象需要分配内存的地方
- 现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件

