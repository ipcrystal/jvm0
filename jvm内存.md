# JVM 内存

- 虚拟机栈 Stack Frame 栈帧
    - 属于线程私有的内存空间
    - 当线程创建的时候，与之相对应的虚拟机栈创建
    - 当线程消亡的时候，虚拟机栈也消失了
- 程序计数器（Program Counter）
    - 用来标识程序需要执行哪一行
    - 也是线程私有的空间
- 本地方法栈
    - native
- 堆（heap）: Java操作对象都是基于引用操作的，JVM管理的最大一块内存空间
    - 与堆相关的一个重要的概念是 垃圾收集器。
    - 现代几乎所有的垃圾收集器都采用的分代收集算法
    - 堆空间也基于这一点进行了相应的空间划分。 新生代 与 老年代。 
        - Eden空间，From Survivor空间，To Survivor空间。
    - Java的堆空间在内存上可以是连续的也可以是不连续的
- 方法区（Method Area）：存储元信息  永久代（Permanent Generation） 从JDK 1.8 开始，已经彻底废弃了永久代，使用元空间（meta space）
    - 主要存放元数据
        - 例如 Class对象，常量
    - 引用（栈） -> 对象（堆） -> 元数据（方法区）
- 运行时常量池（编译期确定的）：方法区的一部分内容。
- 直接内存：Direct Memory
    - 与 Java NIO 密切相关。JVM是通过堆上的DirectByteBuffer来操作直接内存
    

**关于Java对象创建的过程**

- new关键字创建对象的3个步骤
    1. 在堆内存中创建对象的实例。
    2. 为对象的实例成员变量赋初值
    3. 将对象的引用返回

- 指针碰撞
    - ✔✔✔✔✔✔✔✔✖✖✖✖✖✖
    - 前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间
- 空闲列表
    - ✔✖✔✔✔✖✖✖✔✔✖✖✔✔
    - 堆内存空间中已被使用的与未被使用的空间是交织在一起的
    - 这是，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的
    - 接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录

**对象在内存中的布局**

- 对象头
- 实例数据 （即我们在一个类中所声明的各项信息）
- 对齐填充（可选）


**引用指向**
- 引用指向句柄 
    - 引用指向了一个结构
    - 句柄指向堆内存对象
    - 句柄指向元空间数据
- 引用指向堆内存里的对象 （直接指针）
    - 引用指向了对象
    - 堆内存里的对象指向元空间的数据
    
## jvisualvm

- 堆溢出
    - jvm参数参考： `-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError`
- 栈溢出